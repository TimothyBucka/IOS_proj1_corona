#!/usr/bin/env bash
set -u # FIXME after

export POSIXLY_CORRECT=yes
export LC_NUMERIC=en_US.UTF-8

# id,                     1     FIXME
# datum,                  2
# vek,                    3
# pohlavi,                4
# kraj_nuts_kod,          5
# okres_lau_kod,          6
# nakaza_v_zahranici,     7
# nakaza_zeme_csu_kod,    8
# reportovano_khs         9

############################## FUNCTIONS ##############################
check_age() {
    if [[ "$1" =~ ^[0-9]{1,3}$ ]] || [ "$1" == '' ]; then
        return 0
    else
        EXIT_CODE="1"
        return 1
    fi
}

check_date() {
    if [[ "$1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] && [ -n "$(date -d "$1" 2>/dev/null)" ] || [ "$1" == '' ]; then
        return 0
    else
        EXIT_CODE="1"
        return 1
    fi
}

debug_print_values() {
    # FIXME delete this
    echo "-a $A_FILTER and $A_DATETIME"
    echo "-b $B_FILTER and $B_DATETIME"
    echo "-g $G_FILTER and $GENDER"
    echo "-s $S_FILTER and $WIDTH"
    echo "Command: $COMMAND"
}

help() {
    echo "This script filters records of people infected by COVID-19."
    echo ""
    echo "Usage: corona [-h] [FILTERS] [COMMAND] [LOG [LOG2 [...]]"
    echo ""
    echo "   -h              prints help with instructions, and script terminates"
    echo ""
    echo "COMMAND:"
    echo "   infected          prints number of infected"
    echo "   merge             merges multiple input files into one, keeping the original order"
    echo "   gender            prints number of infected for each gender"
    echo "   age               prints number of infected for each age group"
    echo "   daily             prints number of infected for each day"
    echo "   monthly           prints number of infected for each month"
    echo "   yearly            prints number of infected for each year"
    echo "   countries         prints number of infected for each country (CZ not included)"
    echo "   districts         prints number of infected for each district"
    echo "   regions           prints number of infected for each region"
    echo ""
    echo "FILTERS:"
    echo "   -a DATETIME       after: records after given date (included)"
    echo "   -b DATETIME       before: records before given date (included)"
    echo "   -g GENDER         records with given GENDER: M - male (muzi), Z - female (zeny)"
    echo "   -s [WIDTH]        with commands gender, age, daily, monthly, yearly, countries"
    echo "                     districts and regions the data are displayed in a histogram."
    echo "                     WIDTH (optional positive number) sets width of the histogram."
    echo "                     If not given, with is set to default (see documentation)"
    echo "   -d DISTRICT_FILE  for command disrticts prints, instead of the LAU 1 code of"
    echo "                     a district, its proper name. DISTRICT_FILE contains the"
    echo "                     code to name mapping"
    echo "   -r REGIONS_FILE   for command regions prints instead of the NUTS 3 code of"
    echo "                     a region, its proper name. REGIONS_FILE contains the"
    echo "                     code to name mapping"
    echo ""
    echo "If no commands or filters are given, script prints records to standart output"
    echo "Script is able to process .gz or .bz2 files"
    echo "If no files (LOG, LOG2, ...) are given, sript expects records from standart input"
    echo ""
}

traverse_awk() {
    awk -F ',' \
        -v after_date="$A_DATETIME" \
        -v before_date="$B_DATETIME" \
        -v gender="$GENDER" \
        -v width="$WIDTH" \
        -v command="$COMMAND" \
        -v header="$HEADER" \
        '
        function filters_passed() {
            if ($0 ~ /^[[:space:]]*$/ || $0 == header) {
                return 0
            } else if (!($2 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) && $2!="") {
                print "Invalid date: " $0 | "cat 1>&2"
                return 0
            } else if (date_split[2]>12 || date_split[3]>31 || (date_split[3]>30 && (date_split[2]==04 || date_split[2]==06 || date_split[2]==09 || date_split[2]==11)) || (date_split[3]>29 && date_split[2]==02)) {
                print "Invalid date: " $0 | "cat 1>&2"
                return 0
            } else if (!($3 ~ /^[0-9]{1,3}$/) && $3!="") {
                print "Invalid age: " $0 | "cat 1>&2"
                return 0
            } else if ((after_date>$2 || $2>before_date) || (gender!=$4 && gender!="")) {
                return 0
            }
            return 1
        }

        function print_array(arr, def_len) {
            for (i in arr) {
                if (i == "" ) {
                    print "None: " arr[""]
                } else {
                    print i ": " arr[i] | "sort -g"
                }
            }
        }
        
        BEGIN{
            c_infected = 0

            gender_arr["M"] = 0
            gender_arr["Z"] = 0

            age_arr["0-5"] = 0
            age_arr["6-15"] = 0
            age_arr["16-25"] = 0
            age_arr["26-35"] = 0
            age_arr["36-45"] = 0
            age_arr["46-55"] = 0
            age_arr["56-65"] = 0
            age_arr["66-75"] = 0
            age_arr["76-85"] = 0
            age_arr["86-95"] = 0
            age_arr["96-105"] = 0
            age_arr[">105"] = 0
        }{
            gsub(" ", "", $0)
            split($2,date_split,"-")

            if (filters_passed()) {
                if (command == "merge" || command == "") {
                    print $0
                } else {
                    c_infected++
                    gender_arr[$4]++
                    if (command == "age") {
                        if ($3 == "") { age_arr[""]++ }
                        else if ($3 <= 5) { age_arr["0-5"]++ }
                        else if ($3 <= 15) { age_arr["6-15"]++ }
                        else if ($3 <= 25) { age_arr["16-25"]++ }
                        else if ($3 <= 35) { age_arr["26-35"]++ }
                        else if ($3 <= 45) { age_arr["36-45"]++ }
                        else if ($3 <= 55) { age_arr["46-55"]++ }
                        else if ($3 <= 65) { age_arr["56-65"]++ }
                        else if ($3 <= 75) { age_arr["66-75"]++ }
                        else if ($3 <= 85) { age_arr["76-85"]++ }
                        else if ($3 <= 95) { age_arr["86-95"]++ }
                        else if ($3 <= 105) { age_arr["96-105"]++ }
                        else { age_arr[">105"]++ }
                    }
                    day_arr[$2]++
                    month_arr[substr($2, 1, 7)]++
                    year_arr[substr($2, 1, 4)]++
                    if ($8 != "" && $8 != "CZ")
                        country_arr[$8]++
                    district_arr[$6]++
                    region_arr[$5]++
                }
            }
        }END{
            if (command == "infected") {
                print c_infected
            } else if (command == "gender") {
                print_array(gender_arr, 100000)
            } else if (command == "age") {
                print_array(age_arr, 10000)
            } else if (command == "daily") {
                print_array(day_arr, 500)
            } else if (command == "monthly") {
                print_array(month_arr, 10000)
            } else if (command == "yearly") {
                print_array(year_arr, 100000)
            } else if (command == "countries") {
                print_array(country_arr, 100)
            } else if (command == "districts") {
                print_array(district_arr, 1000)
            } else if (command == "regions") {
                print_array(region_arr, 10000)
            }
        }'
}

awk_none_end () {
    awk \
    '{
        if ($0 ~ /None:.*/)
            none_line=$0
        else if ($0 ~ />105:.*/)
            age_line=$0
        else
            print $0
    } END {
        if (age_line != "")
            print age_line
        if (none_line != "")
            print none_line
    }'
}

############################## DATA ##############################
# COMMANDS="infected merge gender age daily monthly yearly countries districts regions"
COMMAND=""

# FILTERS
A_FILTER=""
B_FILTER=""
G_FILTER=""
S_FILTER=""
D_FILTER=""
R_FILTER=""

# filters parameters
A_DATETIME=""
B_DATETIME="2023-01-01"
GENDER=""
WIDTH=""
DISTRICT_FILE=""
REGIONS_FILE=""

EXIT_CODE="0"
HEADER="id,datum,vek,pohlavi,kraj_nuts_kod,okres_lau_kod,nakaza_v_zahranici,nakaza_zeme_csu_kod,reportovano_khs"
LOGS=""

############################## MAIN ##############################
while [ "$#" -gt 0 ]; do
    case "$1" in
    infected | merge | gender | age | daily | monthly | yearly | countries | districts | regions)
        COMMAND=$1
        # fix multiple commands
        ;;
    -a)
        A_FILTER=1
        A_DATETIME=$2
        shift
        ;;
    -b)
        B_FILTER=1
        B_DATETIME=$2
        shift
        ;;
    -g)
        G_FILTER=1
        GENDER=$2
        shift
        ;;
    -s)
        S_FILTER=1
        if [[ "$2" =~ ^[0-9]+$ ]]; then
            WIDTH=$2
            shift
        fi
        ;;
    -d)
        D_FILTER=1
        DISTRICT_FILE=$2
        shift
        ;;
    -r)
        R_FILTER=1
        REGIONS_FILE=$2
        shift
        ;;
    -h)
        help
        exit 0
        ;;
    *)
        LOGS="$LOGS $1"
        ;;
    esac
    shift
done

if [ -z "$COMMAND" ] || [ "$COMMAND" == "merge" ]; then
    echo "$HEADER"
    if [ -z "$LOGS" ]; then
        cat | tail -n +2 | traverse_awk
    else
        for file in $LOGS; do
            if [[ $file == *.gz ]]; then
                gzip -d -c $file | tail -n +2 | traverse_awk
            elif [[ $file == *.bz2 ]]; then
                bzip2 -d -c $file | tail -n +2 | traverse_awk
            else
                cat $file | tail -n +2 | traverse_awk
            fi
        done
    fi
else
    if [ -z "$LOGS" ]; then
        cat | tail -n +2 | traverse_awk | awk_none_end
    else
        if [[ $LOGS == *.gz ]]; then
            gzip -d -c $LOGS | tail -n +2 | traverse_awk | awk_none_end
        elif [[ $LOGS == *.bz2 ]]; then
            bzip2 -d -c $LOGS | tail -n +2 | traverse_awk | awk_none_end
        else
            cat $LOGS | tail -n +2 | traverse_awk | awk_none_end
        fi
    fi
fi

exit "$EXIT_CODE"
